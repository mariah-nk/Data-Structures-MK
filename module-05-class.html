<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>CMPS 260: Module 5 Class</title>
  <style>
    * {
      font-family: monospace;
    }
  </style>
  <script>

    //mariah Kelly

    
    //--------------------------------//
    // The linked list data structure //
    //--------------------------------//
    console.log("The linked list data structure");

    // 1. Suppose you have an array with 1,000 elements and a linked list with 1,000
    //    elements. For both data structures, you want to retrieve the last entry.
    //    Does one data structure complete that operation before the other (i.e.,
    //    is it faster)? If yes, how much faster? If no, why does it take the same
    //    amount of time?



    //------------------------//
    // Creating a linked list //
    //------------------------//
    console.log("Creating a linked list");

    // We are going to implement the linked list data structure described in the
    // book. Instead of using 'let' we use 'var' everywhere. Note that this
    // implementation does not use the prototype (see homework). Here is a skeleton
    // that we will work on completing:



    function LinkedList() {

      // helper class
      function Node(element) {
        this.element = element;
        this.next = null;
      }

      // store length and head
      var length = 0;
      var head = null;


      // class Node {
      //   constructor(val) {
      //     this.val = val;
      //     this.next = null;
      //   }
      // }
      this.append = function (element) {
        // add a new item to the end of the list
        // ...
        var node = new Node(element);
        var current = head;
        if (head === null) {
          head = node;
        }
        else {
          current = head;
          while (current.next) {
            current = current.next;
          }
          //current is now the last node is in the list
          current.next = node;
        }
        length++
      };

      this.insert = function (position, element) {
        // insert a new item at a specific location
        // ...
        if (position >= 0 || position <= length) {
          // Determine valid position
          var node = new Node(element);
          var current = head;
          var previous = 0;
          var index = 0;

          if (position === 0) {
            node.next = current;//next
            head = node;
          }
          else {
    
            while (index++ < position) {
              previous = current;
              current = current.next;
            }
            // make the node point
            node.next = current;
            previous.next = node;

        }
          length++;
          return true;
        }
        else {
          return false;

        }
      };

      this.removeAt = function (position) {
        // remove an element from a specific location
        // ...
        if (position > -1 && position < length) {
          
          var current = head;
          var previous = 0;
          var index = 0;

          if (position === 0) {
            head = current.next;
          }
          else {
            while (index++ < position) {
              previous = current;
              current = current.next;
            }
              previous.next = current.next
            }
            length--;
            return current.element;
          }
          else {
            return null;
        }
      };

      this.remove = function (element) {
        // remove a specific element from the list
        // ...
        // like append but getting rid of
        var current = head;
        var previous;
        if (current.element === element) {

         head = current.next;
}
else {
  while(current.element != element) {
    previous = current;
    current = current.next;
  }
  previous.next = current.next;
}
length--;
      };

      this.indexOf = function (element) {
        // return the index of an element in the list
        // ...
        var count = 0;
        var current = head;
        while (current != null && current.element != element){
          current = current.next;
          count++;
        }
        return count;
      };

      this.isEmpty = function () {
        // check whether the list is empty
        // ...

        return length === 0;
      };

      this.size = function () {
        // return the number of elements in the list
        // ...
        return length;
      };

      this.getHead = function () {
        // return head node
        // ...
        return head;
      }

      this.toString = function () {
        // overwrite the default toString method
        var current = head;
        var string = "List: ";
        while (current) {
          string += current.element + (current.next ? " -> " : "");
          current = current.next;
        }
        return string;
      };

      this.print = function () {
        // print to the console
        console.log(this.toString());
      };

    }

    // create a linked list to operate on
    var list = new LinkedList();

    // 1. Write pseudo code (meaning; use comments) to describe how you would
    //    implement the append method. HINT: What two scenarios can you distinguish?

// the new list calls append with an element of my choice as an argument

    // 2. Translate your pseudo code into actual code and test it.
    //    HINT: Use list.print() to test your code.

    list.append(6);
    list.append(7);
    list.append(8);
    list.append(9);
    list.append(10);
    list.append(11);
    list.append(12);
    list.print();

    // 3. Repeat (1) and (2) for insert.
// I would call insert on list and pass in a position where
// the value will be placed in the list, and a value as the element to be added
// at index 2: the number 100 will appear now

list.insert(2,100);
    list.print();

    // 4. Repeat (1) and (2) for removeAt.

// I will call removeAt on the list in the fourth position (index of 3), 8 should be removed

list.removeAt(3);
list.print();

    // 5. Repeat (1) and (2) for remove.
 
    // I will ask the list to remove the element (6) from it's place. 
    // This is the first element in the list 
    // Then I will remove the element (100)
    
    list.remove(6);
    list.print();
    list.remove(100);
    list.print();

    // 6. Repeat (1) and (2) for indexOf.

// I will call indexOf for the elements 10 and 11,
// I shoudld get 2 & 3 respectively

console.log("10's index: " + list.indexOf(10));
console.log("11's index: " + list.indexOf(11));

    // 7. Repeat (1) and (2) for isEmpty.
// this will return a bool value for whether the list has or does not have elements
// I also will make a new empty list that should return true

console.log("same list, isEmpty() ?: " + list.isEmpty());
var newList = new LinkedList();
console.log("new list, isEmpty() ?: " + newList.isEmpty());

    // 8. Repeat (1) and (2) for size.
// this should return the length of the list, which should be 5
console.log("List size: " + list.size());


    // 9. Repeat (1) and (2) for getHead.

    // this is getting the first node in the list
    // to get the specific element to output, I add that specification with .element
    console.log("getHead(): " + list.getHead().element);



    //---------------------//
    // Doubly linked lists //
    //---------------------//
    console.log("Doubly linked lists");

    // Skip. NOTE: It may be useful to read this section anyway.



    //-----------------------//
    // Circular linked lists //
    //-----------------------//
    console.log("Circular linked lists");

    // Skip. NOTE: It may be useful to read this section anyway.



    //---------//
    // Project //
    //---------//
    console.log("Project");

    // 1. Write a function that takes two linked lists as input and returns true if
    //    they have the same elements, and false otherwise. Test your code.

    function isEqual(list1, list2) {
      // implementation
      
      while (list1 != null && list2 != null){
        var h = list1.head;
        var g = list2.head;

          if (h !== g){
            
            return false;
            }
            else {
              h = list1.next;
              g = list2.next;
            }
            return (h === null && g === null);
          }
        }

    // creating lists to compare

    var e = new LinkedList();

    var x = new LinkedList();
    x.append(1);
    x.append(2);
    x.append(3);
  
    var y = new LinkedList();
    y.append(1);
    y.append(2);
    y.append(3);

    var z = new LinkedList();
    z.append(2);
    z.append(3);

    console.log("Are x & y equal?: " + isEqual(x, y));
    console.log("Are y & x equal?: " + isEqual(y, x));
    console.log("Are y & z equal?: " + isEqual(y, z));
    console.log("Are z & e equal?: " + isEqual(z, e));

    console.log(x);
    console.log(y);

    // 2. Implement the stack data structure using a linked list instead of an
    //    array. Use the prototype.

    function Stack() {
      // put properties here (the linked list)
      // do NOT use this.items = [];
    }

// add methods through the prototype



  </script>
</head>

<body>
</body>

</html>
